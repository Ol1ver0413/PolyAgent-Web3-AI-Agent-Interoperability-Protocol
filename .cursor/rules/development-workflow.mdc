---
description: 
globs: 
alwaysApply: true
---
# 开发工作流指南

## 项目启动流程

### 1. 环境准备
```bash
# 克隆项目
git clone <repository-url>
cd PolyAgent-Web3-AI-Agent-Interoperability-Protocol

# 安装后端依赖
pip install -r requirements.txt

# 安装前端依赖
cd frontEnd
npm install
cd ..

# 安装 MCP 依赖
npm install @alipay/mcp-server-alipay
```

### 2. 配置设置
**检查配置文件** **[AgentCore/config.py](mdc:AgentCore/config.py)**：
```python
# 必需的环境变量
OPENAI_API_KEY = "sk-..."  # OpenAI API 密钥
OPENAI_API_URL = "..."     # API 端点
IOTEX_RPC_URL = "https://babel-api.testnet.iotex.one"
```

### 3. 服务启动顺序
```bash
# 1. 启动后端服务器
python app.py

# 2. 启动前端开发服务器（新终端）
cd frontEnd
npm start
```

## 开发模式

### 后端开发
**主要文件**: **[app.py](mdc:app.py)**

#### 添加新 API 端点
```python
@app.route("/new-endpoint", methods=["POST"])
def handle_new_endpoint():
    """新端点的文档字符串"""
    data = request.json
    message = data.get("message")
    
    if not message:
        return jsonify({"error": "缺少消息字段"}), 400
    
    # 处理逻辑
    return Response(stream_with_context(your_generator()), mimetype="text/plain")
```

#### 创建新 AI Agent
**参考**: **[AgentCore/Society/market_trade.py](mdc:AgentCore/Society/market_trade.py)**

```python
class NewAgent:
    def __init__(self):
        self.model = ModelFactory.create(...)
        self.agent = ChatAgent(
            system_message="Agent 的系统提示...",
            model=self.model,
            token_limit=32768,
            tools=[...],  # 工具包
            output_language="zh"
        )
    
    async def process_request(self, query: str):
        response = await self.agent.astep(query)
        return response.msgs[0].content if response and response.msgs else "未能获取响应"
```

### 前端开发
**主要文件**: **[frontEnd/src/App.tsx](mdc:frontEnd/src/App.tsx)**

#### 添加新 UI 组件
```typescript
// 新组件定义
function NewComponent() {
    const [state, setState] = useState(initialState);
    
    return (
        <div className="component-container">
            {/* 组件内容 */}
        </div>
    );
}

// 集成到主应用
function App() {
    return (
        <div className="app">
            <NewComponent />
        </div>
    );
}
```

#### 添加新 API 调用
```typescript
const callNewAPI = async (message: string) => {
    try {
        const response = await fetch("http://localhost:5000/new-endpoint", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({message})
        });
        
        // 处理流式响应
        const reader = response.body.getReader();
        // ... 流式处理逻辑
    } catch (error) {
        console.error("API调用错误:", error);
    }
};
```

## 测试策略

### 1. 单元测试
**创建测试文件**:
```python
# test_new_feature.py
import unittest
from app import app

class TestNewFeature(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
        
    def test_new_endpoint(self):
        response = self.app.post('/new-endpoint', 
                               json={'message': '测试消息'})
        self.assertEqual(response.status_code, 200)

if __name__ == '__main__':
    unittest.main()
```

### 2. 集成测试
**参考**: **[test_step_by_step.py](mdc:test_step_by_step.py)**

```python
# 完整流程测试
def test_payment_flow():
    steps = [
        ("创建支付", "/payment/create"),
        ("查询状态", "/payment/query"), 
        ("执行转账", "/payment/transfer"),
        ("服务交付", "/payment/story")
    ]
    
    for step_name, endpoint in steps:
        response = requests.post(f"http://localhost:5000{endpoint}")
        assert response.status_code == 200
        print(f"✅ {step_name} 测试通过")
```

### 3. 端到端测试
```bash
# 运行完整演示
python test_step_by_step.py --mode demo
```

## 代码质量标准

### 1. Python 代码规范
- 使用 PEP 8 编码风格
- 添加类型注释（推荐）
- 编写清晰的文档字符串
- 异常处理要具体明确

```python
async def process_payment(self, amount: float) -> Dict[str, Any]:
    """
    处理支付请求
    
    Args:
        amount: 支付金额
        
    Returns:
        包含支付结果的字典
        
    Raises:
        PaymentError: 支付处理失败时抛出
    """
    try:
        # 实现逻辑
        return {"status": "success", "amount": amount}
    except Exception as e:
        raise PaymentError(f"支付处理失败: {e}")
```

### 2. TypeScript 代码规范
- 使用严格类型检查
- 定义清晰的接口
- 组件要有适当的 props 类型

```typescript
interface PaymentFormProps {
    onSubmit: (data: PaymentData) => void;
    isLoading: boolean;
}

const PaymentForm: React.FC<PaymentFormProps> = ({ onSubmit, isLoading }) => {
    // 组件实现
};
```

## 版本控制规范

### 1. Git 分支策略
```bash
main          # 主分支（生产版本）
develop       # 开发分支
feature/*     # 功能分支
hotfix/*      # 紧急修复分支
```

### 2. 提交消息格式
```bash
# 格式：<type>(<scope>): <description>
feat(api): 添加新的支付端点
fix(frontend): 修复钱包连接问题
docs(readme): 更新安装说明
refactor(agent): 重构 MarketAgent 类
```

### 3. 发布流程
```bash
# 1. 功能开发完成后合并到 develop
git checkout develop
git merge feature/new-feature

# 2. 测试通过后合并到 main
git checkout main
git merge develop

# 3. 创建发布标签
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin v1.0.0
```

## 部署指南

### 1. 生产环境准备
```bash
# 安装生产依赖
pip install gunicorn
npm run build  # 构建前端

# 环境变量配置
export FLASK_ENV=production
export OPENAI_API_KEY=your_api_key
```

### 2. 服务器启动
```bash
# 使用 Gunicorn 启动后端
gunicorn -w 4 -b 0.0.0.0:5000 app:app

# 使用 Nginx 服务前端静态文件
# 配置反向代理到后端 API
```

## 监控和维护

### 1. 日志监控
- 实现结构化日志记录
- 监控 AI Agent 响应时间
- 跟踪 API 调用成功率

### 2. 性能监控
- 监控内存使用情况
- 追踪并发 Agent 实例数量
- 优化数据库查询（如有）

### 3. 安全检查
- 定期更新依赖包
- 检查 API 密钥安全性
- 验证输入数据sanitization

## 协作规范

### 1. 代码审查
- 所有 PR 必须经过审查
- 检查功能完整性和代码质量
- 验证测试覆盖率

### 2. 文档更新
- 新功能必须更新相关文档
- API 变更要更新接口文档
- 保持 README 和规则文件同步

### 3. 问题跟踪
- 使用 Issue 跟踪 bug 和功能请求
- 标记优先级和类型标签
- 及时响应和处理反馈

